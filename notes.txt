Negociatition

tcp_timestamps
1=random offset
2=enabled
3=wallclock + random offset
4=wallclock

tcp_transmit_skb adds the options (either tcp_syn_options or tcp_established)

tp->retrans_stamp is used in syn

struct tcp_options_received {
	long	ts_recent_stamp;/* Time we stored ts_recent (for aging) */
	u32	ts_recent;	/* Time stamp to echo next		*/

In timekeeping.c c la d ou je peux recuperer le temps rapidement
ktime_get_real_seconds 
getnstimeofday64
current_kernel_time64
current_kernel_time
timekeeping_get_ns
ktime_get_raw_fast_ns
ktime_get_mono_fast_ns
ktime_get_ts64
ktime_get_raw
ktime_get_resolution_ns ( 	WARN_ON(timekeeping_suspended); )


 * when syncookies are in effect and tcp timestamps are enabled we encode
 * tcp options in the lower bits of the timestamp value that will be
 * sent in the syn-ack.
 * Since subsequent timestamps use the normal tcp_time_stamp value, we
 * must make sure that the resulting initial timestamp is <= tcp_time_stamp.

TODO 
- adapt for RTTs tcp_synack_rtt_meas/tcp_update_rtt_min/tcp_rtt_estimator


tcp_v4_syn_recv_sock is called once 3WHS has completed
tcp_synack_rtt_meas

tcp_synack_rtt_meas
tcp_synack_rtt_meas
Listening procedure:
tcp_rcv_state_process( "if (sk->sk_state == TCP_NEW_SYN_RECV)" ) -> tcp_conn_request -> tcp_openreq_init



ACK path for mptcp
mptcp_sub_retransmit_timer
mptcp_ack_timer/mptcp_ack_retransmit_timer concern
mptcp_established_options -> mptcp_write_dss_data_ack (used in
		mptcp_save_dss_data_seq and mptcp_options_write)


tcp_options_write calls -> mptcp_options_write

Reinjections related:
- mptcp_is_reinjected


maybe I should use tcp_send_ack, it is used in a variety of places
mptcp_queue_skbgit diff-tree --check EMPTY HEAD
- __tcp_ack_snd_check
- mptcp_cleanup_rbuf


===========
mptcp_queue_skbg is where changes should happen.
Add mptcp_send_ack_on_fast_path

Interestingly we have:
/* Quick ACK if more 3/4 of the receive window is filled */
if (after64(tp->mptcp->map_data_seq,
		rcv_nxt64 + 3 * (tcp_receive_window(meta_tp) >> 2)))
	tcp_enter_quickack_mode(sk);

time related mptcp_set_rto

TCP_MAX_QUICKACKS


Les timers sont definies comme 
#define TCP_RTO_MAX	((unsigned)(120*HZ))
tcp_set_rto


static inline u32 __tcp_set_rto(const struct tcp_sock *tp)
{
	return usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);
}

This sentence is weird
	 * 1. If rtt variance happened to be less 50msec, it is hallucination.

	 Pour TLP tail loss probe regarder 
	 tcp_schedule_loss_probe


Probes:
- tcp_send_loss_probe
