Negociatition

tcp_timestamps
1=random offset
2=enabled
3=wallclock + random offset
4=wallclock

tcp_transmit_skb adds the options (either tcp_syn_options or tcp_established)

tp->retrans_stamp is used in syn

struct tcp_options_received {
	long	ts_recent_stamp;/* Time we stored ts_recent (for aging) */
	u32	ts_recent;	/* Time stamp to echo next		*/

In timekeeping.c c la d ou je peux recuperer le temps rapidement


 * when syncookies are in effect and tcp timestamps are enabled we encode
 * tcp options in the lower bits of the timestamp value that will be
 * sent in the syn-ack.
 * Since subsequent timestamps use the normal tcp_time_stamp value, we
 * must make sure that the resulting initial timestamp is <= tcp_time_stamp.

TODO 
- adapt for RTTs tcp_synack_rtt_meas/tcp_update_rtt_min/tcp_rtt_estimator


tcp_v4_syn_recv_sock is called once 3WHS has completed
tcp_synack_rtt_meas
Listening procedure:
tcp_rcv_state_process( "if (sk->sk_state == TCP_NEW_SYN_RECV)" ) -> tcp_conn_request -> tcp_openreq_init



ACK path for mptcp
mptcp_sub_retransmit_timer
mptcp_ack_timer/mptcp_ack_retransmit_timer concern
mptcp_established_options -> mptcp_write_dss_data_ack (used in
		mptcp_save_dss_data_seq and mptcp_options_write)

tcp_options_write calls -> mptcp_options_write

Look at where it's best to reinject is

==== MY ADDITIONS ===
mptcp_send_ack_on_fast_path

==== REINJECTIONS RELATED ===
- mptcp_is_reinjected / MPTCP_REINJECT
- mptcp_reinject_data -> __mptcp_reinject_data
- mptcp_retransmit_skb
- seen in mptcp_push_pending_frames
	 "But, MPTCP also checks packets_out, as this is an
	 indication that we might want to do opportunistic reinjection."
1/ mptcp_write_xmit demande au scheduler.next_segment() le prochain segment 
Dans le scheduler par defaut, quand il n'y a plus d'espace dans la snd_wnd de la
meta & different de la reinjection, mptcp_next_segment() dans mptcp_sched.c appelle
mptcp_rcv_buf_optimization qui fait la reinjection opportuniste:

 /* Sets *@reinject to 1 if the returned segment comes from the
 * reinject queue. Sets it to 0 if it is the regular send-head of the meta-sk,
 * and sets it to -1 if it is a meta-level retransmission to optimize the
 * receive-buffer. */

reinjections can occur with mptcp_meta_retransmit_timer too


le choix du sous-flot ou retransmettre est fait par 
We need more choice on where to send the packet

	subsk = meta_tp->mpcb->sched_ops->get_subflow(meta_sk, skb, false);

mptcp_skb_entail
__tcp_push_pending_frames

Le chemin est trouve la ?!
mptcp_find_and_set_pathmask
En fait il ne choisit pas reellement ou reinjecter (aka laisse le scheduler)
In tcp_skb_cb
		__u32 path_mask; /* paths that tried to send this skb */

maybe I should use tcp_send_ack, it is used in a variety of places
mptcp_queue_skbgit diff-tree --check EMPTY HEAD
- __tcp_ack_snd_check
- mptcp_cleanup_rbuf

=== TAIL LOSS PROBE ===
- tlp.patch est un patch a l'envers (git apply -R tlp.patch) mais l'ancetre
n'existe pas dans mon arbre
- tcp_probe_timer
Ajoute send_loss_probe/


=== Schedulers ===
- implementes dans mptcp_rr.c / mptcp_sched.c /
mptcp mptcp_sched_default

===========
mptcp_queue_skbg is where changes should happen.

> 

Interestingly we have:
/* Quick ACK if more 3/4 of the receive window is filled */
if (after64(tp->mptcp->map_data_seq,
		rcv_nxt64 + 3 * (tcp_receive_window(meta_tp) >> 2)))
	tcp_enter_quickack_mode(sk);

time related mptcp_set_rto

TCP_MAX_QUICKACKS


Les timers sont definies comme 
#define TCP_RTO_MAX	((unsigned)(120*HZ))
tcp_set_rto


static inline u32 __tcp_set_rto(const struct tcp_sock *tp)
{
	return usecs_to_jiffies((tp->srtt_us >> 3) + tp->rttvar_us);
}

This sentence is weird
	 * 1. If rtt variance happened to be less 50msec, it is hallucination.

	 Pour TLP tail loss probe regarder 
	 tcp_schedule_loss_probe

__tcp_ack_snd_check -> mptcp dataack on fastest path

Probes:
- tcp_send_loss_probe
